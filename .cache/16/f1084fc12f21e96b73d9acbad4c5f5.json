{"id":"../../node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js","dependencies":[{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js.map","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/source/block-and-log-streamer.ts","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/package.json","includedInParent":true,"mtime":1541472665906},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/package.json","includedInParent":true,"mtime":1541472826494},{"name":"./block-reconciler","loc":{"line":38,"column":33},"parent":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js","resolved":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-reconciler.js"},{"name":"./log-reconciler","loc":{"line":39,"column":31},"parent":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js","resolved":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/log-reconciler.js"},{"name":"immutable","loc":{"line":40,"column":26},"parent":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js","resolved":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/immutable/dist/immutable.js"},{"name":"uuid","loc":{"line":41,"column":25},"parent":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-and-log-streamer.js","resolved":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/node_modules/uuid/index.js"}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar block_reconciler_1 = require(\"./block-reconciler\");\r\nvar log_reconciler_1 = require(\"./log-reconciler\");\r\nvar immutable_1 = require(\"immutable\");\r\nvar createUuid = require(\"uuid\");\r\nvar BlockAndLogStreamer = /** @class */ (function () {\r\n    /**\r\n     * @param getBlockByHash async function that returns a block given a particular hash or null/throws if the block is not found\r\n     * @param getLogs async function that returns the logs matching the given filter\r\n     * @param onError called if a subscriber throws an error, the error will otherwise be swallowed\r\n     * @param configuration additional optional configuration items\r\n     */\r\n    function BlockAndLogStreamer(getBlockByHash, getLogs, onError, configuration) {\r\n        var _this = this;\r\n        this.lastKnownGoodBlockHistory = immutable_1.List();\r\n        this.blockHistory = Promise.resolve(this.lastKnownGoodBlockHistory);\r\n        this.lastKnownGoodLogHistory = immutable_1.List();\r\n        this.logHistory = Promise.resolve(this.lastKnownGoodLogHistory);\r\n        this.pendingCallbacks = [];\r\n        this.onError = function () { };\r\n        this.logFilters = {};\r\n        this.onBlockAddedSubscribers = {};\r\n        this.onBlockRemovedSubscribers = {};\r\n        this.onLogAddedSubscribers = {};\r\n        this.onLogRemovedSubscribers = {};\r\n        this.reconcileNewBlock = function (block) { return __awaiter(_this, void 0, void 0, function () {\r\n            var blockHistory, logHistory, error_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 3, , 4]);\r\n                        this.blockHistory = block_reconciler_1.reconcileBlockHistory(this.getBlockByHash, this.blockHistory, block, this.onBlockAdded, this.onBlockRemoved, this.blockRetention);\r\n                        return [4 /*yield*/, this.blockHistory];\r\n                    case 1:\r\n                        blockHistory = _a.sent();\r\n                        return [4 /*yield*/, this.logHistory];\r\n                    case 2:\r\n                        logHistory = _a.sent();\r\n                        // everything reconciled correctly, checkpoint state\r\n                        this.lastKnownGoodBlockHistory = blockHistory;\r\n                        this.lastKnownGoodLogHistory = logHistory;\r\n                        this.pendingCallbacks.forEach(function (callback) { return callback(); });\r\n                        this.pendingCallbacks = [];\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        error_1 = _a.sent();\r\n                        // NOTE: this catch block may be hit multiple times for a single failure root cause, thus we need to be careful to only do idempotent operations in here\r\n                        // something went wrong, rollback to last checkpoint\r\n                        this.blockHistory = Promise.resolve(this.lastKnownGoodBlockHistory);\r\n                        this.logHistory = Promise.resolve(this.lastKnownGoodLogHistory);\r\n                        this.pendingCallbacks = [];\r\n                        throw error_1;\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.onBlockAdded = function (block) { return __awaiter(_this, void 0, void 0, function () {\r\n            var logFilters;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        Object.keys(this.onBlockAddedSubscribers)\r\n                            .map(function (key) { return _this.onBlockAddedSubscribers[key]; })\r\n                            .map(function (callback) { return logAndSwallowWrapper(callback, _this.onError); })\r\n                            .forEach(function (callback) { return _this.pendingCallbacks.push(function () { return callback(block); }); });\r\n                        logFilters = Object.keys(this.logFilters).map(function (key) { return _this.logFilters[key]; });\r\n                        this.logHistory = log_reconciler_1.reconcileLogHistoryWithAddedBlock(this.getLogs, this.logHistory, block, this.onLogAdded, logFilters, this.blockRetention);\r\n                        return [4 /*yield*/, this.logHistory];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.onBlockRemoved = function (block) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.logHistory = log_reconciler_1.reconcileLogHistoryWithRemovedBlock(this.logHistory, block, this.onLogRemoved);\r\n                        return [4 /*yield*/, this.logHistory];\r\n                    case 1:\r\n                        _a.sent();\r\n                        Object.keys(this.onBlockRemovedSubscribers)\r\n                            .map(function (key) { return _this.onBlockRemovedSubscribers[key]; })\r\n                            .map(function (callback) { return logAndSwallowWrapper(callback, _this.onError); })\r\n                            .forEach(function (callback) { return _this.pendingCallbacks.push(function () { return callback(block); }); });\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.onLogAdded = function (log) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                Object.keys(this.onLogAddedSubscribers)\r\n                    .map(function (key) { return _this.onLogAddedSubscribers[key]; })\r\n                    .map(function (callback) { return logAndSwallowWrapper(callback, _this.onError); })\r\n                    .forEach(function (callback) { return _this.pendingCallbacks.push(function () { return callback(log); }); });\r\n                return [2 /*return*/];\r\n            });\r\n        }); };\r\n        this.onLogRemoved = function (log) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                Object.keys(this.onLogRemovedSubscribers)\r\n                    .map(function (key) { return _this.onLogRemovedSubscribers[key]; })\r\n                    .map(function (callback) { return logAndSwallowWrapper(callback, _this.onError); })\r\n                    .forEach(function (callback) { return _this.pendingCallbacks.push(function () { return callback(log); }); });\r\n                return [2 /*return*/];\r\n            });\r\n        }); };\r\n        this.getLatestReconciledBlock = function () {\r\n            return _this.lastKnownGoodBlockHistory.isEmpty() ? null : _this.lastKnownGoodBlockHistory.last();\r\n        };\r\n        this.addLogFilter = function (filter) {\r\n            var uuid = \"log filter token \" + createUuid();\r\n            _this.logFilters[uuid] = filter;\r\n            return uuid;\r\n        };\r\n        this.removeLogFilter = function (token) {\r\n            if (!token.startsWith(\"log filter token \"))\r\n                throw new Error(\"Expected a log filter token.  Actual: \" + token);\r\n            delete _this.logFilters[token];\r\n        };\r\n        this.subscribeToOnBlockAdded = function (onBlockAdded) {\r\n            var uuid = \"on block added token \" + createUuid();\r\n            _this.onBlockAddedSubscribers[uuid] = onBlockAdded;\r\n            return uuid;\r\n        };\r\n        this.unsubscribeFromOnBlockAdded = function (token) {\r\n            if (!token.startsWith(\"on block added token \"))\r\n                throw new Error(\"Expected a block added subscription token.  Actual: \" + token);\r\n            delete _this.onBlockAddedSubscribers[token];\r\n        };\r\n        this.subscribeToOnBlockRemoved = function (onBlockRemoved) {\r\n            var uuid = \"on block removed token \" + createUuid();\r\n            _this.onBlockRemovedSubscribers[uuid] = onBlockRemoved;\r\n            return uuid;\r\n        };\r\n        this.unsubscribeFromOnBlockRemoved = function (token) {\r\n            if (!token.startsWith(\"on block removed token \"))\r\n                throw new Error(\"Expected a block added subscription token.  Actual: \" + token);\r\n            delete _this.onBlockRemovedSubscribers[token];\r\n        };\r\n        this.subscribeToOnLogAdded = function (onLogAdded) {\r\n            var uuid = \"on log added token \" + createUuid();\r\n            _this.onLogAddedSubscribers[uuid] = onLogAdded;\r\n            return uuid;\r\n        };\r\n        this.unsubscribeFromOnLogAdded = function (token) {\r\n            if (!token.startsWith(\"on log added token \"))\r\n                throw new Error(\"Expected a log added subscription token.  Actual: \" + token);\r\n            delete _this.onLogAddedSubscribers[token];\r\n        };\r\n        this.subscribeToOnLogRemoved = function (onLogRemoved) {\r\n            var uuid = \"on log removed token \" + createUuid();\r\n            _this.onLogRemovedSubscribers[uuid] = onLogRemoved;\r\n            return uuid;\r\n        };\r\n        this.unsubscribeFromOnLogRemoved = function (token) {\r\n            if (!token.startsWith(\"on log removed token \"))\r\n                throw new Error(\"Expected a log added subscription token.  Actual: \" + token);\r\n            delete _this.onLogRemovedSubscribers[token];\r\n        };\r\n        if (getBlockByHash === undefined)\r\n            throw new Error(\"getBlockByHash must be provided\");\r\n        this.getBlockByHash = getBlockByHash;\r\n        if (getLogs === undefined)\r\n            throw new Error(\"getLogs must be provided\");\r\n        this.getLogs = getLogs;\r\n        if (onError === undefined)\r\n            throw new Error(\"onError must be provided\");\r\n        this.onError = onError;\r\n        this.blockRetention = (configuration && configuration.blockRetention) ? configuration.blockRetention : 100;\r\n    }\r\n    return BlockAndLogStreamer;\r\n}());\r\nexports.BlockAndLogStreamer = BlockAndLogStreamer;\r\nfunction logAndSwallowWrapper(callback, onError) {\r\n    return function (parameter) {\r\n        try {\r\n            callback(parameter);\r\n        }\r\n        catch (error) {\r\n            onError(error);\r\n        }\r\n    };\r\n}\r\n","map":{"version":3,"file":"block-and-log-streamer.js","sourceRoot":"","sources":["../../source/block-and-log-streamer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Block } from \"./models/block\";\nimport { Log } from \"./models/log\";\nimport { Filter, FilterOptions } from \"./models/filters\";\nimport { BlockHistory } from \"./models/block-history\";\nimport { LogHistory } from \"./models/log-history\";\nimport { reconcileBlockHistory } from \"./block-reconciler\";\nimport { reconcileLogHistoryWithAddedBlock, reconcileLogHistoryWithRemovedBlock } from \"./log-reconciler\";\n\nimport { List as ImmutableList } from \"immutable\";\nimport * as createUuid from \"uuid\";\n\nexport interface Configuration {\n\t/** number of blocks to retain in history, defaults to 100 */\n\tblockRetention?: number\n}\n\nexport class BlockAndLogStreamer<TBlock extends Block, TLog extends Log> {\n\tprivate lastKnownGoodBlockHistory: BlockHistory<TBlock> = ImmutableList<TBlock>();\n\tprivate blockHistory: Promise<BlockHistory<TBlock>> = Promise.resolve(this.lastKnownGoodBlockHistory);\n\tprivate lastKnownGoodLogHistory: LogHistory<TLog> = ImmutableList<TLog>();\n\tprivate logHistory: Promise<LogHistory<TLog>> = Promise.resolve(this.lastKnownGoodLogHistory);\n\tprivate pendingCallbacks: Array<() => void> = [];\n\n\tprivate readonly blockRetention: number;\n\n\tprivate readonly getBlockByHash: (hash: string) => Promise<TBlock | null>;\n\tprivate readonly getLogs: (filterOptions: FilterOptions) => Promise<TLog[]>;\n\tprivate readonly onError: (error: Error) => void = () => {};\n\n\tprivate readonly logFilters: { [propName: string]: Filter } = {}\n\tprivate readonly onBlockAddedSubscribers: { [propName: string]: (block: TBlock) => void } = {};\n\tprivate readonly onBlockRemovedSubscribers: { [propName: string]: (block: TBlock) => void } = {};\n\tprivate readonly onLogAddedSubscribers: { [propName: string]: (log: TLog) => void } = {};\n\tprivate readonly onLogRemovedSubscribers: { [propName: string]: (log: TLog) => void } = {};\n\n\t/**\n\t * @param getBlockByHash async function that returns a block given a particular hash or null/throws if the block is not found\n\t * @param getLogs async function that returns the logs matching the given filter\n\t * @param onError called if a subscriber throws an error, the error will otherwise be swallowed\n\t * @param configuration additional optional configuration items\n\t */\n\tconstructor(\n\t\tgetBlockByHash: (hash: string) => Promise<TBlock | null>,\n\t\tgetLogs: (filterOptions: FilterOptions) => Promise<TLog[]>,\n\t\tonError: (error: Error) => void,\n\t\tconfiguration?: Configuration,\n\t) {\n\t\tif (getBlockByHash === undefined) throw new Error(`getBlockByHash must be provided`);\n\t\tthis.getBlockByHash = getBlockByHash;\n\t\tif (getLogs === undefined) throw new Error(`getLogs must be provided`);\n\t\tthis.getLogs = getLogs;\n\t\tif (onError === undefined) throw new Error(`onError must be provided`);\n\t\tthis.onError = onError;\n\t\tthis.blockRetention = (configuration && configuration.blockRetention) ? configuration.blockRetention : 100;\n\t}\n\n\tpublic readonly reconcileNewBlock = async (block: TBlock): Promise<void> => {\n\t\ttry {\n\t\t\tthis.blockHistory = reconcileBlockHistory(this.getBlockByHash, this.blockHistory, block, this.onBlockAdded, this.onBlockRemoved, this.blockRetention);\n\t\t\tconst blockHistory = await this.blockHistory;\n\t\t\tconst logHistory = await this.logHistory;\n\t\t\t// everything reconciled correctly, checkpoint state\n\t\t\tthis.lastKnownGoodBlockHistory = blockHistory;\n\t\t\tthis.lastKnownGoodLogHistory = logHistory;\n\t\t\tthis.pendingCallbacks.forEach(callback => callback());\n\t\t\tthis.pendingCallbacks = [];\n\t\t} catch (error) {\n\t\t\t// NOTE: this catch block may be hit multiple times for a single failure root cause, thus we need to be careful to only do idempotent operations in here\n\t\t\t// something went wrong, rollback to last checkpoint\n\t\t\tthis.blockHistory = Promise.resolve(this.lastKnownGoodBlockHistory);\n\t\t\tthis.logHistory = Promise.resolve(this.lastKnownGoodLogHistory);\n\t\t\tthis.pendingCallbacks = [];\n\t\t\tthrow error;\n\t\t}\n\t};\n\n\tprivate readonly onBlockAdded = async (block: TBlock): Promise<void> => {\n\t\tObject.keys(this.onBlockAddedSubscribers)\n\t\t\t.map((key: string) => this.onBlockAddedSubscribers[key])\n\t\t\t.map(callback => logAndSwallowWrapper(callback, this.onError))\n\t\t\t.forEach(callback => this.pendingCallbacks.push(() => callback(block)));\n\n\t\tconst logFilters = Object.keys(this.logFilters).map(key => this.logFilters[key]);\n\t\tthis.logHistory = reconcileLogHistoryWithAddedBlock(this.getLogs, this.logHistory, block, this.onLogAdded, logFilters, this.blockRetention);\n\t\tawait this.logHistory;\n\t};\n\n\tprivate readonly onBlockRemoved = async (block: TBlock): Promise<void> => {\n\t\tthis.logHistory = reconcileLogHistoryWithRemovedBlock(this.logHistory, block, this.onLogRemoved);\n\t\tawait this.logHistory;\n\n\t\tObject.keys(this.onBlockRemovedSubscribers)\n\t\t\t.map((key: string) => this.onBlockRemovedSubscribers[key])\n\t\t\t.map(callback => logAndSwallowWrapper(callback, this.onError))\n\t\t\t.forEach(callback => this.pendingCallbacks.push(() => callback(block)));\n\t};\n\n\tprivate readonly onLogAdded = async (log: TLog): Promise<void> => {\n\t\tObject.keys(this.onLogAddedSubscribers)\n\t\t\t.map((key: string) => this.onLogAddedSubscribers[key])\n\t\t\t.map(callback => logAndSwallowWrapper(callback, this.onError))\n\t\t\t.forEach(callback => this.pendingCallbacks.push(() => callback(log)));\n\t};\n\n\tprivate readonly onLogRemoved = async (log: TLog): Promise<void> => {\n\t\tObject.keys(this.onLogRemovedSubscribers)\n\t\t\t.map((key: string) => this.onLogRemovedSubscribers[key])\n\t\t\t.map(callback => logAndSwallowWrapper(callback, this.onError))\n\t\t\t.forEach(callback => this.pendingCallbacks.push(() => callback(log)));\n\t};\n\n\n\tpublic readonly getLatestReconciledBlock = (): TBlock | null => {\n\t\treturn this.lastKnownGoodBlockHistory.isEmpty() ? null : this.lastKnownGoodBlockHistory.last();\n\t};\n\n\n\tpublic readonly addLogFilter = (filter: Filter): string => {\n\t\tconst uuid = `log filter token ${createUuid()}`;\n\t\tthis.logFilters[uuid] = filter;\n\t\treturn uuid;\n\t};\n\n\tpublic readonly removeLogFilter = (token: string): void => {\n\t\tif (!token.startsWith(\"log filter token \")) throw new Error(`Expected a log filter token.  Actual: ${token}`);\n\t\tdelete this.logFilters[token];\n\t};\n\n\n\tpublic readonly subscribeToOnBlockAdded = (onBlockAdded: (block: TBlock) => void): string => {\n\t\tconst uuid = `on block added token ${createUuid()}`;\n\t\tthis.onBlockAddedSubscribers[uuid] = onBlockAdded;\n\t\treturn uuid;\n\t};\n\n\tpublic readonly unsubscribeFromOnBlockAdded = (token: string) => {\n\t\tif (!token.startsWith(\"on block added token \")) throw new Error(`Expected a block added subscription token.  Actual: ${token}`);\n\t\tdelete this.onBlockAddedSubscribers[token];\n\t};\n\n\n\tpublic readonly subscribeToOnBlockRemoved = (onBlockRemoved: (block: TBlock) => void): string => {\n\t\tconst uuid = `on block removed token ${createUuid()}`;\n\t\tthis.onBlockRemovedSubscribers[uuid] = onBlockRemoved;\n\t\treturn uuid;\n\t};\n\n\tpublic readonly unsubscribeFromOnBlockRemoved = (token: string) => {\n\t\tif (!token.startsWith(\"on block removed token \")) throw new Error(`Expected a block added subscription token.  Actual: ${token}`);\n\t\tdelete this.onBlockRemovedSubscribers[token];\n\t};\n\n\n\tpublic readonly subscribeToOnLogAdded = (onLogAdded: (log: TLog) => void): string => {\n\t\tconst uuid = `on log added token ${createUuid()}`;\n\t\tthis.onLogAddedSubscribers[uuid] = onLogAdded;\n\t\treturn uuid;\n\t};\n\n\tpublic readonly unsubscribeFromOnLogAdded = (token: string) => {\n\t\tif (!token.startsWith(\"on log added token \")) throw new Error(`Expected a log added subscription token.  Actual: ${token}`);\n\t\tdelete this.onLogAddedSubscribers[token];\n\t};\n\n\n\tpublic readonly subscribeToOnLogRemoved = (onLogRemoved: (log: TLog) => void): string => {\n\t\tconst uuid = `on log removed token ${createUuid()}`;\n\t\tthis.onLogRemovedSubscribers[uuid] = onLogRemoved;\n\t\treturn uuid;\n\t};\n\n\tpublic readonly unsubscribeFromOnLogRemoved = (token: string) => {\n\t\tif (!token.startsWith(\"on log removed token \")) throw new Error(`Expected a log added subscription token.  Actual: ${token}`);\n\t\tdelete this.onLogRemovedSubscribers[token];\n\t};\n}\n\nfunction logAndSwallowWrapper<T>(callback: (arg: T) => void, onError: (error: Error) => void): (arg: T) => void {\n\treturn function (parameter) {\n\t\ttry {\n\t\t\tcallback(parameter);\n\t\t} catch (error) {\n\t\t\tonError(error);\n\t\t}\n\t};\n}\n"]}},"hash":"4235e87686c58bee248d4a80f4d92873","cacheData":{"env":{}}}