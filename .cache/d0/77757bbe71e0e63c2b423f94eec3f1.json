{"id":"../../node_modules/ethereumjs-blockstream/output/source/block-reconciler.js","dependencies":[{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/block-reconciler.js.map","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/source/block-reconciler.ts","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/package.json","includedInParent":true,"mtime":1541472665906},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/package.json","includedInParent":true,"mtime":1541472826494}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar _this = this;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.reconcileBlockHistory = function (getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention) {\r\n    if (blockRetention === void 0) { blockRetention = 100; }\r\n    return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, blockHistory];\r\n                case 1:\r\n                    blockHistory = _a.sent();\r\n                    if (!isFirstBlock(blockHistory)) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\r\n                case 2: return [2 /*return*/, _a.sent()];\r\n                case 3:\r\n                    if (!isOlderThanOldestBlock(blockHistory, newBlock)) return [3 /*break*/, 6];\r\n                    return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\r\n                case 4:\r\n                    blockHistory = _a.sent();\r\n                    return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\r\n                case 5: return [2 /*return*/, _a.sent()];\r\n                case 6:\r\n                    if (isAlreadyInHistory(blockHistory, newBlock))\r\n                        return [2 /*return*/, blockHistory];\r\n                    if (!isNewHeadBlock(blockHistory, newBlock)) return [3 /*break*/, 8];\r\n                    return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\r\n                case 7: return [2 /*return*/, _a.sent()];\r\n                case 8:\r\n                    if (!parentHashIsInHistory(blockHistory, newBlock)) return [3 /*break*/, 13];\r\n                    _a.label = 9;\r\n                case 9:\r\n                    if (!(blockHistory.last().hash !== newBlock.parentHash)) return [3 /*break*/, 11];\r\n                    return [4 /*yield*/, removeHeadBlock(blockHistory, onBlockRemoved)];\r\n                case 10:\r\n                    blockHistory = _a.sent();\r\n                    return [3 /*break*/, 9];\r\n                case 11: return [4 /*yield*/, addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention)];\r\n                case 12: return [2 /*return*/, _a.sent()];\r\n                case 13: return [4 /*yield*/, backfill(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention)];\r\n                case 14: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    });\r\n};\r\nvar rollback = function (blockHistory, onBlockRemoved) { return __awaiter(_this, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!!blockHistory.isEmpty()) return [3 /*break*/, 2];\r\n                return [4 /*yield*/, removeHeadBlock(blockHistory, onBlockRemoved)];\r\n            case 1:\r\n                // CONSIDER: if this throws an exception, removals may have been announced that are actually still in history since throwing will result in no history update. we can't catch errors here because there isn't a clear way to recover from them, the failure may be a downstream system telling us that the block removal isn't possible because they are in a bad state. we could try re-announcing the successfully added blocks, but there would still be a problem with the failed block (should it be re-announced?) and the addition announcements may also fail\r\n                blockHistory = _a.sent();\r\n                return [3 /*break*/, 0];\r\n            case 2: return [2 /*return*/, blockHistory];\r\n        }\r\n    });\r\n}); };\r\nvar backfill = function (getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention) { return __awaiter(_this, void 0, void 0, function () {\r\n    var parentBlock;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!(newBlock.parentHash === \"0x0000000000000000000000000000000000000000000000000000000000000000\")) return [3 /*break*/, 2];\r\n                return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\r\n            case 1: return [2 /*return*/, _a.sent()];\r\n            case 2: return [4 /*yield*/, getBlockByHash(newBlock.parentHash)];\r\n            case 3:\r\n                parentBlock = _a.sent();\r\n                if (parentBlock === null)\r\n                    throw new Error(\"Failed to fetch parent block.\");\r\n                if (!(parseInt(parentBlock.number, 16) + blockRetention < parseInt(blockHistory.last().number, 16))) return [3 /*break*/, 5];\r\n                return [4 /*yield*/, rollback(blockHistory, onBlockRemoved)];\r\n            case 4: return [2 /*return*/, _a.sent()];\r\n            case 5: return [4 /*yield*/, exports.reconcileBlockHistory(getBlockByHash, blockHistory, parentBlock, onBlockAdded, onBlockRemoved, blockRetention)];\r\n            case 6:\r\n                blockHistory = _a.sent();\r\n                return [4 /*yield*/, exports.reconcileBlockHistory(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention)];\r\n            case 7: return [2 /*return*/, _a.sent()];\r\n        }\r\n    });\r\n}); };\r\nvar addNewHeadBlock = function (blockHistory, newBlock, onBlockAdded, blockRetention) { return __awaiter(_this, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                // this is here as a final sanity check, in case we somehow got into an unexpected state, there are no known (and should never be) ways to reach this exception\r\n                if (!blockHistory.isEmpty() && blockHistory.last().hash !== newBlock.parentHash)\r\n                    throw new Error(\"New head block's parent isn't our current head.\");\r\n                // CONSIDER: the user getting this notification won't have any visibility into the updated block history yet. should we announce new blocks in a `setTimeout`? should we provide block history with new logs? an announcement failure will result in unwinding the stack and returning the original blockHistory, if we are in the process of backfilling we may have already announced previous blocks that won't actually end up in history (they won't get removed if a re-org occurs and may be re-announced). we can't catch errors thrown by the callback because it may be trying to signal to use that the block has become invalid and is un-processable\r\n                return [4 /*yield*/, onBlockAdded(newBlock)];\r\n            case 1:\r\n                // CONSIDER: the user getting this notification won't have any visibility into the updated block history yet. should we announce new blocks in a `setTimeout`? should we provide block history with new logs? an announcement failure will result in unwinding the stack and returning the original blockHistory, if we are in the process of backfilling we may have already announced previous blocks that won't actually end up in history (they won't get removed if a re-org occurs and may be re-announced). we can't catch errors thrown by the callback because it may be trying to signal to use that the block has become invalid and is un-processable\r\n                _a.sent();\r\n                blockHistory = blockHistory.push(newBlock);\r\n                return [2 /*return*/, blockHistory.takeLast(blockRetention).toList()];\r\n        }\r\n    });\r\n}); };\r\nvar removeHeadBlock = function (blockHistory, onBlockRemoved) { return __awaiter(_this, void 0, void 0, function () {\r\n    var removedBlock;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                removedBlock = blockHistory.last();\r\n                blockHistory = blockHistory.pop();\r\n                return [4 /*yield*/, onBlockRemoved(removedBlock)];\r\n            case 1:\r\n                _a.sent();\r\n                return [2 /*return*/, blockHistory];\r\n        }\r\n    });\r\n}); };\r\nvar isFirstBlock = function (blockHistory) {\r\n    return blockHistory.isEmpty();\r\n};\r\nvar isOlderThanOldestBlock = function (blockHistory, newBlock) {\r\n    return parseInt(blockHistory.first().number, 16) > parseInt(newBlock.number, 16);\r\n};\r\nvar isAlreadyInHistory = function (blockHistory, newBlock) {\r\n    // `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\r\n    return blockHistory.some(function (block) { return block.hash === newBlock.hash; });\r\n};\r\nvar isNewHeadBlock = function (blockHistory, newBlock) {\r\n    return blockHistory.last().hash === newBlock.parentHash;\r\n};\r\nvar parentHashIsInHistory = function (blockHistory, newBlock) {\r\n    // `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\r\n    return blockHistory.some(function (block) { return block.hash === newBlock.parentHash; });\r\n};\r\n","map":{"version":3,"file":"block-reconciler.js","sourceRoot":"","sources":["../../source/block-reconciler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Block } from \"./models/block\";\nimport { BlockHistory } from \"./models/block-history\";\nimport { List as ImmutableList } from \"immutable\";\n\ntype GetBlockByHash<TBlock> = (hash: string) => Promise<TBlock|null>;\n\nexport const reconcileBlockHistory = async <TBlock extends Block>(\n\tgetBlockByHash: GetBlockByHash<TBlock>,\n\tblockHistory: BlockHistory<TBlock>|Promise<BlockHistory<TBlock>>,\n\tnewBlock: TBlock,\n\tonBlockAdded: (block: TBlock) => Promise<void>,\n\tonBlockRemoved: (block: TBlock) => Promise<void>,\n\tblockRetention: number = 100,\n): Promise<BlockHistory<TBlock>> => {\n\tblockHistory = await blockHistory;\n\tif (isFirstBlock(blockHistory))\n\t\treturn await addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention);\n\n\tif (isOlderThanOldestBlock(blockHistory, newBlock)) {\n\t\tblockHistory = await rollback(blockHistory, onBlockRemoved);\n\t\treturn await addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention);\n\t}\n\n\tif (isAlreadyInHistory(blockHistory, newBlock))\n\t\treturn blockHistory;\n\n\tif (isNewHeadBlock(blockHistory, newBlock))\n\t\treturn await addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention);\n\n\tif (parentHashIsInHistory(blockHistory, newBlock)) {\n\t\twhile (blockHistory.last().hash !== newBlock.parentHash) {\n\t\t\tblockHistory = await removeHeadBlock(blockHistory, onBlockRemoved);\n\t\t}\n\t\treturn await addNewHeadBlock(blockHistory, newBlock, onBlockAdded, blockRetention);\n\t}\n\n\treturn await backfill(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention);\n}\n\nconst rollback = async <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, onBlockRemoved: (block: TBlock) => Promise<void>): Promise<BlockHistory<TBlock>> => {\n\twhile (!blockHistory.isEmpty()) {\n\t\t// CONSIDER: if this throws an exception, removals may have been announced that are actually still in history since throwing will result in no history update. we can't catch errors here because there isn't a clear way to recover from them, the failure may be a downstream system telling us that the block removal isn't possible because they are in a bad state. we could try re-announcing the successfully added blocks, but there would still be a problem with the failed block (should it be re-announced?) and the addition announcements may also fail\n\t\tblockHistory = await removeHeadBlock(blockHistory, onBlockRemoved);\n\t}\n\treturn blockHistory;\n}\n\nconst backfill = async <TBlock extends Block>(getBlockByHash: GetBlockByHash<TBlock>, blockHistory: BlockHistory<TBlock>, newBlock: TBlock, onBlockAdded: (block: TBlock) => Promise<void>, onBlockRemoved: (block: TBlock) => Promise<void>, blockRetention: number): Promise<BlockHistory<TBlock>> => {\n\tif (newBlock.parentHash === \"0x0000000000000000000000000000000000000000000000000000000000000000\")\n\t\treturn await rollback(blockHistory, onBlockRemoved);\n\tconst parentBlock = await getBlockByHash(newBlock.parentHash);\n\tif (parentBlock === null) throw new Error(\"Failed to fetch parent block.\");\n\tif (parseInt(parentBlock.number, 16) + blockRetention < parseInt(blockHistory.last().number, 16))\n\t\treturn await rollback(blockHistory, onBlockRemoved);\n\tblockHistory = await reconcileBlockHistory(getBlockByHash, blockHistory, parentBlock, onBlockAdded, onBlockRemoved, blockRetention);\n\treturn await reconcileBlockHistory(getBlockByHash, blockHistory, newBlock, onBlockAdded, onBlockRemoved, blockRetention);\n}\n\nconst addNewHeadBlock = async <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, newBlock: TBlock, onBlockAdded: (block: TBlock) => Promise<void>, blockRetention: number): Promise<BlockHistory<TBlock>> => {\n\t// this is here as a final sanity check, in case we somehow got into an unexpected state, there are no known (and should never be) ways to reach this exception\n\tif (!blockHistory.isEmpty() && blockHistory.last().hash !== newBlock.parentHash) throw new Error(\"New head block's parent isn't our current head.\");\n\t// CONSIDER: the user getting this notification won't have any visibility into the updated block history yet. should we announce new blocks in a `setTimeout`? should we provide block history with new logs? an announcement failure will result in unwinding the stack and returning the original blockHistory, if we are in the process of backfilling we may have already announced previous blocks that won't actually end up in history (they won't get removed if a re-org occurs and may be re-announced). we can't catch errors thrown by the callback because it may be trying to signal to use that the block has become invalid and is un-processable\n\tawait onBlockAdded(newBlock);\n\tblockHistory = blockHistory.push(newBlock);\n\treturn blockHistory.takeLast(blockRetention).toList();\n}\n\nconst removeHeadBlock = async <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, onBlockRemoved: (block: TBlock) => Promise<void>): Promise<BlockHistory<TBlock>> => {\n\tlet removedBlock = blockHistory.last();\n\tblockHistory = blockHistory.pop();\n\tawait onBlockRemoved(removedBlock);\n\treturn blockHistory;\n}\n\nconst isFirstBlock = <TBlock extends Block>(blockHistory: BlockHistory<TBlock>): boolean => {\n\treturn blockHistory.isEmpty();\n}\n\nconst isOlderThanOldestBlock = <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, newBlock: TBlock): boolean => {\n\treturn parseInt(blockHistory.first().number, 16) > parseInt(newBlock.number, 16);\n}\n\nconst isAlreadyInHistory = <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, newBlock: TBlock): boolean => {\n\t// `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\n\treturn blockHistory.some(block => block!.hash === newBlock.hash);\n}\n\nconst isNewHeadBlock = <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, newBlock: TBlock): boolean => {\n\treturn blockHistory.last().hash === newBlock.parentHash;\n}\n\nconst parentHashIsInHistory = <TBlock extends Block>(blockHistory: BlockHistory<TBlock>, newBlock: TBlock): boolean => {\n\t// `block!` is required until the next version of `immutable` is published to NPM (current version 3.8.1) which improves the type definitions\n\treturn blockHistory.some(block => block!.hash === newBlock.parentHash);\n}\n"]}},"hash":"7c55d2fe327df408ca8401d65f09f3a2","cacheData":{"env":{}}}