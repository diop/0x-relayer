{"id":"../../node_modules/ethereumjs-blockstream/output/source/log-reconciler.js","dependencies":[{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/output/source/log-reconciler.js.map","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/source/log-reconciler.ts","includedInParent":true,"mtime":1541472826494},{"name":"/Users/fodediop/dev/backend/0x-starter-project/package.json","includedInParent":true,"mtime":1541472665906},{"name":"/Users/fodediop/dev/backend/0x-starter-project/node_modules/ethereumjs-blockstream/package.json","includedInParent":true,"mtime":1541472826494}],"generated":{"js":"\"use strict\";\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar _this = this;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.reconcileLogHistoryWithAddedBlock = function (getLogs, logHistory, newBlock, onLogAdded, filters, historyBlockLength) {\r\n    if (filters === void 0) { filters = []; }\r\n    if (historyBlockLength === void 0) { historyBlockLength = 100; }\r\n    return __awaiter(_this, void 0, void 0, function () {\r\n        var logs;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, logHistory];\r\n                case 1:\r\n                    logHistory = _a.sent();\r\n                    return [4 /*yield*/, getFilteredLogs(getLogs, newBlock, filters)];\r\n                case 2:\r\n                    logs = _a.sent();\r\n                    return [4 /*yield*/, addNewLogsToHead(logHistory, logs, onLogAdded)];\r\n                case 3:\r\n                    logHistory = _a.sent();\r\n                    return [4 /*yield*/, pruneOldLogs(logHistory, newBlock, historyBlockLength)];\r\n                case 4:\r\n                    logHistory = _a.sent();\r\n                    return [2 /*return*/, logHistory];\r\n            }\r\n        });\r\n    });\r\n};\r\nvar getFilteredLogs = function (getLogs, newBlock, filters) { return __awaiter(_this, void 0, void 0, function () {\r\n    var logPromises, nestedLogs;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                logPromises = filters\r\n                    .map(function (filter) { return ({ blockHash: newBlock.hash, address: filter.address, topics: filter.topics, }); })\r\n                    .map(function (filter) { return getLogs(filter); });\r\n                return [4 /*yield*/, Promise.all(logPromises)];\r\n            case 1:\r\n                nestedLogs = _a.sent();\r\n                return [2 /*return*/, nestedLogs.reduce(function (allLogs, logs) { return allLogs.concat(logs); }, [])];\r\n        }\r\n    });\r\n}); };\r\nvar addNewLogsToHead = function (logHistory, newLogs, onLogAdded) { return __awaiter(_this, void 0, void 0, function () {\r\n    var sortedLogs, _loop_1, _i, sortedLogs_1, logToAdd;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                sortedLogs = newLogs.sort(function (logA, logB) { return parseInt(logA.logIndex, 16) - parseInt(logB.logIndex, 16); });\r\n                _loop_1 = function (logToAdd) {\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0:\r\n                                // we may already have this log because two filters can return the same log\r\n                                if (logHistory.some(function (logInHistory) { return logInHistory.blockHash === logToAdd.blockHash && logInHistory.logIndex === logToAdd.logIndex; }))\r\n                                    return [2 /*return*/, \"continue\"];\r\n                                ensureOrder(logHistory.last(), logToAdd);\r\n                                return [4 /*yield*/, addNewLogToHead(logHistory, logToAdd, onLogAdded)];\r\n                            case 1:\r\n                                logHistory = _a.sent();\r\n                                return [2 /*return*/];\r\n                        }\r\n                    });\r\n                };\r\n                _i = 0, sortedLogs_1 = sortedLogs;\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!(_i < sortedLogs_1.length)) return [3 /*break*/, 4];\r\n                logToAdd = sortedLogs_1[_i];\r\n                return [5 /*yield**/, _loop_1(logToAdd)];\r\n            case 2:\r\n                _a.sent();\r\n                _a.label = 3;\r\n            case 3:\r\n                _i++;\r\n                return [3 /*break*/, 1];\r\n            case 4: return [2 /*return*/, logHistory];\r\n        }\r\n    });\r\n}); };\r\nvar pruneOldLogs = function (logHistory, newBlock, historyBlockLength) { return __awaiter(_this, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        // `log!` is required until the next major version of `immutable` is published to NPM (current version 3.8.2) which improves the type definitions\r\n        return [2 /*return*/, logHistory.skipUntil(function (log) { return parseInt(newBlock.number, 16) - parseInt(log.blockNumber, 16) < historyBlockLength; }).toList()];\r\n    });\r\n}); };\r\nvar addNewLogToHead = function (logHistory, newLog, onLogAdded) { return __awaiter(_this, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                logHistory = logHistory.push(newLog);\r\n                // CONSIDER: the user getting this notification won't have any visibility into the updated log history yet. should we announce new logs in a `setTimeout`? should we provide log history with new logs?\r\n                return [4 /*yield*/, onLogAdded(newLog)];\r\n            case 1:\r\n                // CONSIDER: the user getting this notification won't have any visibility into the updated log history yet. should we announce new logs in a `setTimeout`? should we provide log history with new logs?\r\n                _a.sent();\r\n                return [2 /*return*/, logHistory];\r\n        }\r\n    });\r\n}); };\r\nvar ensureOrder = function (headLog, newLog) {\r\n    if (headLog === undefined)\r\n        return;\r\n    var headBlockNumber = parseInt(headLog.blockNumber, 16);\r\n    var newLogBlockNumber = parseInt(newLog.blockNumber, 16);\r\n    if (headBlockNumber > newLogBlockNumber)\r\n        throw new Error(\"received log for a block (\" + newLogBlockNumber + \") older than current head log's block (\" + headBlockNumber + \")\");\r\n    if (headBlockNumber !== newLogBlockNumber)\r\n        return;\r\n    var headLogIndex = parseInt(headLog.logIndex, 16);\r\n    var newLogIndex = parseInt(newLog.logIndex, 16);\r\n    if (headLogIndex >= newLogIndex)\r\n        throw new Error(\"received log with same block number (\" + newLogBlockNumber + \") but index (\" + newLogIndex + \") is the same or older than previous index (\" + headLogIndex + \")\");\r\n};\r\nexports.reconcileLogHistoryWithRemovedBlock = function (logHistory, removedBlock, onLogRemoved) { return __awaiter(_this, void 0, void 0, function () {\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0: return [4 /*yield*/, logHistory];\r\n            case 1:\r\n                logHistory = _a.sent();\r\n                _a.label = 2;\r\n            case 2:\r\n                if (!(!logHistory.isEmpty() && logHistory.last().blockHash === removedBlock.hash)) return [3 /*break*/, 4];\r\n                return [4 /*yield*/, onLogRemoved(logHistory.last())];\r\n            case 3:\r\n                _a.sent();\r\n                logHistory = logHistory.pop();\r\n                return [3 /*break*/, 2];\r\n            case 4:\r\n                // sanity check, no known way to trigger the error\r\n                if (logHistory.some(function (log) { return log.blockHash === removedBlock.hash; }))\r\n                    throw new Error(\"found logs for removed block not at head of log history\");\r\n                return [2 /*return*/, logHistory];\r\n        }\r\n    });\r\n}); };\r\n","map":{"version":3,"file":"log-reconciler.js","sourceRoot":"","sources":["../../source/log-reconciler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Block } from \"./models/block\";\nimport { Log } from \"./models/log\";\nimport { Filter, FilterOptions } from \"./models/filters\";\nimport { LogHistory } from \"./models/log-history\";\n\nexport const reconcileLogHistoryWithAddedBlock = async <TBlock extends Block, TLog extends Log>(\n\tgetLogs: (filterOptions: FilterOptions) => Promise<TLog[]>,\n\tlogHistory: LogHistory<TLog> | Promise<LogHistory<TLog>>,\n\tnewBlock: TBlock,\n\tonLogAdded: (log: TLog) => Promise<void>,\n\tfilters: Filter[] = [],\n\thistoryBlockLength: number = 100,\n): Promise<LogHistory<TLog>> => {\n\tlogHistory = await logHistory;\n\tconst logs = await getFilteredLogs(getLogs, newBlock, filters);\n\tlogHistory = await addNewLogsToHead(logHistory, logs, onLogAdded);\n\tlogHistory = await pruneOldLogs(logHistory, newBlock, historyBlockLength);\n\treturn logHistory;\n}\n\nconst getFilteredLogs = async <TBlock extends Block, TLog extends Log>(getLogs: (filterOptions: FilterOptions) => Promise<Array<TLog>>, newBlock: TBlock, filters: Array<Filter>): Promise<Array<TLog>> => {\n\tconst logPromises = filters\n\t\t.map(filter => ({ blockHash: newBlock.hash, address: filter.address, topics: filter.topics, }))\n\t\t.map(filter => getLogs(filter));\n\tconst nestedLogs = await Promise.all(logPromises);\n\treturn nestedLogs.reduce((allLogs, logs) => allLogs.concat(logs), []);\n}\n\nconst addNewLogsToHead = async <TLog extends Log>(logHistory: LogHistory<TLog>, newLogs: Array<TLog>, onLogAdded: (log: TLog) => Promise<void>): Promise<LogHistory<TLog>> => {\n\tconst sortedLogs = newLogs.sort((logA, logB) => parseInt(logA.logIndex, 16) - parseInt(logB.logIndex, 16));\n\tfor (const logToAdd of sortedLogs) {\n\t\t// we may already have this log because two filters can return the same log\n\t\tif (logHistory.some(logInHistory => logInHistory!.blockHash === logToAdd.blockHash && logInHistory!.logIndex === logToAdd.logIndex)) continue;\n\t\tensureOrder(logHistory.last(), logToAdd);\n\t\tlogHistory = await addNewLogToHead(logHistory, logToAdd, onLogAdded);\n\t}\n\treturn logHistory;\n}\n\nconst pruneOldLogs = async <TBlock extends Block, TLog extends Log>(logHistory: LogHistory<TLog>, newBlock: TBlock, historyBlockLength: number): Promise<LogHistory<TLog>> => {\n\t// `log!` is required until the next major version of `immutable` is published to NPM (current version 3.8.2) which improves the type definitions\n\treturn logHistory.skipUntil(log => parseInt(newBlock.number, 16) - parseInt(log!.blockNumber, 16) < historyBlockLength).toList();\n}\n\nconst addNewLogToHead = async <TLog extends Log>(logHistory: LogHistory<TLog>, newLog: TLog, onLogAdded: (log: TLog) => Promise<void>): Promise<LogHistory<TLog>> => {\n\tlogHistory = logHistory.push(newLog);\n\t// CONSIDER: the user getting this notification won't have any visibility into the updated log history yet. should we announce new logs in a `setTimeout`? should we provide log history with new logs?\n\tawait onLogAdded(newLog);\n\treturn logHistory;\n}\n\nconst ensureOrder = <TLog extends Log>(headLog: TLog | undefined, newLog: TLog) => {\n\tif (headLog === undefined) return;\n\tconst headBlockNumber = parseInt(headLog.blockNumber, 16);\n\tconst newLogBlockNumber = parseInt(newLog.blockNumber, 16);\n\tif (headBlockNumber > newLogBlockNumber) throw new Error(`received log for a block (${newLogBlockNumber}) older than current head log's block (${headBlockNumber})`);\n\tif (headBlockNumber !== newLogBlockNumber) return;\n\tconst headLogIndex = parseInt(headLog.logIndex, 16);\n\tconst newLogIndex = parseInt(newLog.logIndex, 16);\n\tif (headLogIndex >= newLogIndex) throw new Error(`received log with same block number (${newLogBlockNumber}) but index (${newLogIndex}) is the same or older than previous index (${headLogIndex})`);\n}\n\nexport const reconcileLogHistoryWithRemovedBlock = async <TBlock extends Block, TLog extends Log>(\n\tlogHistory: LogHistory<TLog>|Promise<LogHistory<TLog>>,\n\tremovedBlock: TBlock,\n\tonLogRemoved: (log: TLog) => Promise<void>,\n): Promise<LogHistory<TLog>> => {\n\tlogHistory = await logHistory;\n\n\twhile (!logHistory.isEmpty() && logHistory.last().blockHash === removedBlock.hash) {\n\t\tawait onLogRemoved(logHistory.last());\n\t\tlogHistory = logHistory.pop();\n\t}\n\n\t// sanity check, no known way to trigger the error\n\tif (logHistory.some(log => log!.blockHash === removedBlock.hash)) throw new Error(\"found logs for removed block not at head of log history\");\n\n\treturn logHistory;\n}\n"]}},"hash":"67deb4a5138dce9f6097afb7c0ea63bb","cacheData":{"env":{}}}